import { NextRequest, NextResponse } from 'next/server';
import { PDFDocument, StandardFonts, rgb } from 'pdf-lib';

export async function POST(req: NextRequest) {
  try {
    const { messages, version = '2.3' } = await req.json();

    if (!messages || messages.length === 0) {
      return NextResponse.json(
        { error: 'No messages to export' },
        { status: 400 }
      );
    }

    // Create PDF document
    const pdfDoc = await PDFDocument.create();
    const helvetica = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const helveticaBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
    
    // MA3 yellow color
    const ma3Yellow = rgb(1, 0.8, 0);
    const black = rgb(0, 0, 0);
    const gray = rgb(0.4, 0.4, 0.4);

    let page = pdfDoc.addPage();
    const { width, height } = page.getSize();
    let yPosition = height - 50;
    
    // Header
    page.drawText('grandMA3 Docs Search', {
      x: 50,
      y: yPosition,
      size: 20,
      font: helveticaBold,
      color: ma3Yellow,
    });
    
    yPosition -= 20;
    page.drawText(`Version ${version} • Exported ${new Date().toLocaleDateString()}`, {
      x: 50,
      y: yPosition,
      size: 10,
      font: helvetica,
      color: gray,
    });
    
    yPosition -= 30;
    
    // Messages
    for (const message of messages) {
      // Check if we need a new page
      if (yPosition < 100) {
        page = pdfDoc.addPage();
        yPosition = height - 50;
      }
      
      // Role header
      const role = message.role === 'user' ? 'You' : 'Assistant';
      const roleColor = message.role === 'user' ? ma3Yellow : gray;
      
      page.drawText(role + ':', {
        x: 50,
        y: yPosition,
        size: 12,
        font: helveticaBold,
        color: roleColor,
      });
      
      yPosition -= 20;
      
      // Message content
      const text = message.content || '';
      const lines = wrapText(text, 90); // Wrap at 90 characters
      
      for (const line of lines) {
        if (yPosition < 50) {
          page = pdfDoc.addPage();
          yPosition = height - 50;
        }
        
        page.drawText(line, {
          x: 50,
          y: yPosition,
          size: 10,
          font: helvetica,
          color: black,
        });
        
        yPosition -= 15;
      }
      
      // Citations if present
      if (message.citations && message.citations.length > 0) {
        yPosition -= 5;
        page.drawText('Citations:', {
          x: 50,
          y: yPosition,
          size: 9,
          font: helveticaBold,
          color: gray,
        });
        yPosition -= 12;
        
        for (const citation of message.citations) {
          if (yPosition < 50) {
            page = pdfDoc.addPage();
            yPosition = height - 50;
          }
          
          const citationText = `• ${citation.title} - ${citation.url}`;
          const citationLines = wrapText(citationText, 85);
          
          for (const line of citationLines) {
            page.drawText(line, {
              x: 60,
              y: yPosition,
              size: 8,
              font: helvetica,
              color: gray,
            });
            yPosition -= 12;
          }
        }
      }
      
      yPosition -= 20; // Space between messages
    }
    
    // Footer on last page
    page.drawText('Generated by grandMA3 Docs Search', {
      x: 50,
      y: 30,
      size: 8,
      font: helvetica,
      color: gray,
    });

    // Generate PDF bytes
    const pdfBytes = await pdfDoc.save();

    // Return PDF as download
    return new NextResponse(Buffer.from(pdfBytes), {
      status: 200,
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `attachment; filename="grandma3-chat-${Date.now()}.pdf"`,
      },
    });
  } catch (error) {
    console.error('PDF export error:', error);
    return NextResponse.json(
      { error: 'Failed to export PDF' },
      { status: 500 }
    );
  }
}

// Helper function to wrap text
function wrapText(text: string, maxCharsPerLine: number): string[] {
  const words = text.split(' ');
  const lines: string[] = [];
  let currentLine = '';

  for (const word of words) {
    if ((currentLine + word).length <= maxCharsPerLine) {
      currentLine += (currentLine ? ' ' : '') + word;
    } else {
      if (currentLine) lines.push(currentLine);
      currentLine = word;
    }
  }
  
  if (currentLine) lines.push(currentLine);
  return lines;
}